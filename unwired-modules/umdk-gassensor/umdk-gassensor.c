/*
 * Copyright (C) 2016-2018 Unwired Devices LLC <info@unwds.com>

 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the Software
 * is furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
 * FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * @defgroup
 * @ingroup
 * @brief
 * @{
 * @file        umdk-gassensor.c
 * @brief       LMP91000-based gas sensor module
 * @author 
 * @todo        To realize a temperature compensation of concentration of gas     
 */

#ifdef __cplusplus
extern "C" {
#endif

/* define is autogenerated, do not change */
#undef _UMDK_MID_
#define _UMDK_MID_ UNWDS_GASSENSOR_MODULE_ID

/* define is autogenerated, do not change */
#undef _UMDK_NAME_
#define _UMDK_NAME_ "gassensor"

#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

#include "periph/gpio.h"
#include "periph/adc.h"
#include "board.h"

#include "lmp91000.h"

#include "umdk-ids.h"
#include "unwds-common.h"

#include "umdk-gassensor.h"

#include "thread.h"
#include "rtctimers-millis.h"

static uwnds_cb_t *callback;

static kernel_pid_t timer_pid;

static msg_t timer_msg = {};
static rtctimers_millis_t timer;

static bool is_polled = false;

static struct {
    uint8_t                     publish_period_sec;
    umdk_gassensor_sensor_t     sensor_type;
    int32_t                     sensor_code;
} gassensor_config;

static lmp91000_t        lmp91000;
static lmp91000_config_t lmp91000_config;


static int32_t _tia_gain_calc(lmp91000_config_t config, uint32_t ext_gain) {
    uint32_t tia_gain = 0;

    if (ext_gain > 1000000)
        return -1;

    switch(config.tiacn.tia_gain) {
        case LMP91000_TIA_GAIN_EXT:
            tia_gain = (ext_gain);
            break;
        case LMP91000_TIA_GAIN_2KOHM75:
            tia_gain = (2750 * ext_gain) / (2750 + ext_gain);
            break;
        case LMP91000_TIA_GAIN_3KOHM5:
            tia_gain = (3500 * ext_gain) / (3500 + ext_gain);
            break;
        case LMP91000_TIA_GAIN_7KOHM:
            ext_gain /= 1000;
            tia_gain = ((7 * ext_gain) / (7 + ext_gain)) * 1000;
            tia_gain += (((7 * ext_gain) % (7 + ext_gain)) * 1000) / (7 + ext_gain);
            break;
        case LMP91000_TIA_GAIN_14KOHM:
            ext_gain /= 1000;
            tia_gain = ((14 * ext_gain) / (14 + ext_gain)) * 1000;
            tia_gain += (((14 * ext_gain) % (14 + ext_gain)) * 1000) / (14 + ext_gain);
            break;
        case LMP91000_TIA_GAIN_35KOHM:
            ext_gain /= 1000;
            tia_gain = ((35 * ext_gain) / (35 + ext_gain)) * 1000;
            tia_gain += ((35 * ext_gain) % (35 + ext_gain)*1000)/(35 + ext_gain);
            break;
        case LMP91000_TIA_GAIN_120KOHM:
            ext_gain /= 1000;
            tia_gain = ((120 * ext_gain) / (120 + ext_gain)) * 1000;
            tia_gain += (((120 * ext_gain) % (120 + ext_gain)) * 1000) / (120 + ext_gain);
            break;
        case LMP91000_TIA_GAIN_350KOHM:
            ext_gain /= 1000;
            tia_gain = ((350 * ext_gain) / (350 + ext_gain)) * 1000;
            tia_gain += (((350 * ext_gain) % (350 + ext_gain)) * 1000) / (350 + ext_gain);
            break;
        default:
            tia_gain = ext_gain;
            break;
    }
    return tia_gain;
}

static void reset_config(void) {
    gassensor_config.publish_period_sec = UMDK_GASSENSOR_PUBLISH_PERIOD_MIN;
    gassensor_config.sensor_type = UMDK_GASSENSOR_UNKNOWN;
    gassensor_config.sensor_code = 0;
}

static void init_config(void) {
    reset_config();

    if (!unwds_read_nvram_config(_UMDK_MID_, (uint8_t *) &gassensor_config, sizeof(gassensor_config))) {
        puts("Resetting config... Not read nwram");
        reset_config();
    }
        
    printf("[umdk-" _UMDK_NAME_ "] Publish period: %d min\n", gassensor_config.publish_period_sec);
}

static inline void save_config(void) {
    unwds_write_nvram_config(_UMDK_MID_, (uint8_t *) &gassensor_config, sizeof(gassensor_config));
}

static void init_gassensor(void) {
    lmp91000_params_t lmp91000_params[] = { GASSENSOR_PARAMS_BOARD };
    
    
    /* Initialize ACD */
    if (adc_init(UMDK_GASSENSOR_ADC_LINE) == 0) {
        puts("[umdk-" _UMDK_NAME_ "] Internal ADC initialized");
    }

    /* Iniatilize hardware AFE*/
    printf("[umdk-" _UMDK_NAME_ "] Initializing hardware GASSENSOR on I2C #%d\n", lmp91000_params[0].i2c);
    if (lmp91000_init_hw(&lmp91000, lmp91000_params[0]) == LMP91000_OK) {
        puts("[umdk-" _UMDK_NAME_ "] lmp91000 AFE hardware initialized");
    }

    /* Iniatalize internal analog schematic LMP91000 */
    switch(gassensor_config.sensor_type) {
        case UMDK_GASSENSOR_CO:
            lmp91000_config.tiacn.tia_gain   = LMP91000_TIA_GAIN_EXT;
            lmp91000_config.tiacn.r_load     = LMP91000_RLOAD_10OHM;
            lmp91000_config.refcn.bias       = LMP91000_BIAS_01PCT;
            lmp91000_config.refcn.bias_sign  = LMP91000_BIAS_SIGN_POS;
            lmp91000_config.refcn.int_z      = LMP91000_INT_Z_20PCT;
            lmp91000_config.refcn.ref_source = LMP91000_REF_SOURCE_INT;
            lmp91000_config.modecn.op_mode   = LMP91000_OP_MODE_3_LEAD_AMP_CELL;
            lmp91000_config.modecn.fet_short = LMP91000_FET_SHORT_DISABLED;
            if (lmp91000_set_configure(&lmp91000, lmp91000_config) != LMP91000_OK)
                puts("[umdk-" _UMDK_NAME_ "] lmp91000 not found");
            break;
        case UMDK_GASSENSOR_H2S:
            lmp91000_config.tiacn.tia_gain   = LMP91000_TIA_GAIN_EXT;
            lmp91000_config.tiacn.r_load     = LMP91000_RLOAD_10OHM;
            lmp91000_config.refcn.bias       = LMP91000_BIAS_00PCT;
            lmp91000_config.refcn.bias_sign  = LMP91000_BIAS_SIGN_POS;
            lmp91000_config.refcn.int_z      = LMP91000_INT_Z_20PCT;
            lmp91000_config.refcn.ref_source = LMP91000_REF_SOURCE_INT;
            lmp91000_config.modecn.op_mode   = LMP91000_OP_MODE_3_LEAD_AMP_CELL;
            lmp91000_config.modecn.fet_short = LMP91000_FET_SHORT_DISABLED;
            if (lmp91000_set_configure(&lmp91000, lmp91000_config) != LMP91000_OK)
                puts("[umdk-" _UMDK_NAME_ "] lmp91000 not found");
            break;
        case UMDK_GASSENSOR_NO2:
            lmp91000_config.tiacn.tia_gain   = LMP91000_TIA_GAIN_EXT;
            lmp91000_config.tiacn.r_load     = LMP91000_RLOAD_10OHM;
            lmp91000_config.refcn.bias       = LMP91000_BIAS_10PCT;
            lmp91000_config.refcn.bias_sign  = LMP91000_BIAS_SIGN_NEG;
            lmp91000_config.refcn.int_z      = LMP91000_INT_Z_50PCT;
            lmp91000_config.refcn.ref_source = LMP91000_REF_SOURCE_INT;
            lmp91000_config.modecn.op_mode   = LMP91000_OP_MODE_3_LEAD_AMP_CELL;
            lmp91000_config.modecn.fet_short = LMP91000_FET_SHORT_DISABLED;
            if (lmp91000_set_configure(&lmp91000, lmp91000_config) != LMP91000_OK)
                puts("[umdk-" _UMDK_NAME_ "] lmp91000 not found");
            break;
        case UMDK_GASSENSOR_SO2:
            lmp91000_config.tiacn.tia_gain   = LMP91000_TIA_GAIN_EXT;
            lmp91000_config.tiacn.r_load     = LMP91000_RLOAD_10OHM;
            lmp91000_config.refcn.bias       = LMP91000_BIAS_10PCT;
            lmp91000_config.refcn.bias_sign  = LMP91000_BIAS_SIGN_POS;
            lmp91000_config.refcn.int_z      = LMP91000_INT_Z_50PCT;
            lmp91000_config.refcn.ref_source = LMP91000_REF_SOURCE_INT;
            lmp91000_config.modecn.op_mode   = LMP91000_OP_MODE_3_LEAD_AMP_CELL;
            lmp91000_config.modecn.fet_short = LMP91000_FET_SHORT_DISABLED;
            if (lmp91000_set_configure(&lmp91000, lmp91000_config) != LMP91000_OK)
                puts("[umdk-" _UMDK_NAME_ "] lmp91000 not found");
        case UMDK_GASSENSOR_O3:
            lmp91000_config.tiacn.tia_gain   = LMP91000_TIA_GAIN_EXT;
            lmp91000_config.tiacn.r_load     = LMP91000_RLOAD_10OHM;
            lmp91000_config.refcn.bias       = LMP91000_BIAS_01PCT;
            lmp91000_config.refcn.bias_sign  = LMP91000_BIAS_SIGN_NEG;
            lmp91000_config.refcn.int_z      = LMP91000_INT_Z_50PCT;
            lmp91000_config.refcn.ref_source = LMP91000_REF_SOURCE_INT;
            lmp91000_config.modecn.op_mode   = LMP91000_OP_MODE_3_LEAD_AMP_CELL;
            lmp91000_config.modecn.fet_short = LMP91000_FET_SHORT_DISABLED;
            if (lmp91000_set_configure(&lmp91000, lmp91000_config) != LMP91000_OK)
                puts("[umdk-" _UMDK_NAME_ "] lmp91000 not found");
            break;
        case UMDK_GASSENSOR_UNKNOWN:
            puts("[umdk-" _UMDK_NAME_ "] Unknown sensor type");
            /* do Nothing */
            break;
        default:
            /* do Nothing */
            break;
    }
}

static void prepare_result(module_data_t *buf)
{
    

    if ((gassensor_config.sensor_type != UMDK_GASSENSOR_UNKNOWN) && (gassensor_config.sensor_code != 0)) { 
        uint32_t ppm;
        /* obtain data */
        int32_t calib_factor;
        uint16_t v_ref;

        uint16_t sample = adc_sample(UMDK_GASSENSOR_ADC_LINE, UMDK_GASSENSOR_ADC_RESOLUTION);

        /* VDD scaling */
        if (UMDK_GASSENSOR_CONVERT_TO_MILLIVOLTS) {
            v_ref = adc_sample(ADC_LINE(ADC_VREF_INDEX), UMDK_GASSENSOR_ADC_RESOLUTION);
            printf("[umdk-" _UMDK_NAME_ "] VREF line #%d: %d\n", ADC_VREF_INDEX, v_ref);
        }

        if (UMDK_GASSENSOR_CONVERT_TO_MILLIVOLTS) {
            /* Calculate Vdd */
            uint32_t full_scale = 0;
            
            switch (UMDK_GASSENSOR_ADC_RESOLUTION) {
                case ADC_RES_12BIT:
                    full_scale = 4095;
                    break;
                case ADC_RES_10BIT:
                    full_scale = 1023;
                    break;
                case ADC_RES_8BIT:
                    full_scale = 255;
                    break;
                case ADC_RES_6BIT:
                    full_scale = 63;
                    break;
                default:
                    puts("[umdk-" _UMDK_NAME_ "] Unsupported ADC resolution, aborting.");
                    return;
                    break; 
            }
            sample = (uint32_t)(sample * v_ref) / full_scale;
        }
        
        printf("[umdk-" _UMDK_NAME_ "] Reading line #%d: %d\n", UMDK_GASSENSOR_ADC_LINE, sample);
        
        convert_to_be_sam((void *)&sample, sizeof(sample));
        /* Calculate M */
        /* M(V/ppm) = SensCode(pA/ppm)*TIA_Gain(V/A)*10^-12(A/pA) */
        int32_t gain =_tia_gain_calc(lmp91000_config, UMDK_GASSENSOR_EXT_GAIN);                
        if (gain != -1) {
            gain /= 1000;
            calib_factor = (gassensor_config.sensor_code * gain) / 1000000000;
            printf("M = %ld\n", calib_factor);
            ppm = ((1 / calib_factor) * (sample - v_ref)) / 1000; 
        }

        convert_to_be_sam((void *)&ppm, sizeof(ppm));

        if (buf) {
            buf->data[0] = _UMDK_MID_;
            buf->data[1] = UMDK_GASSENSOR_DATA;
            memcpy(buf->data + 2, (void *)&ppm, sizeof(ppm));
            memcpy(buf->data + 2 + sizeof(ppm), (void *)&sample, sizeof(sample));
            buf->length = sizeof(ppm) + 2 + sizeof(sample);
        }
    } else {
        puts("[umdk-" _UMDK_NAME_ "] Unknown sensor type");
        if (buf) {
            buf->data[0] = _UMDK_MID_;
            buf->data[1] = UMDK_GASSENSOR_FAIL;
            buf->length = 2;
        }
    }
}

static void *timer_thread(void *arg)
{
    (void)arg;
    
    msg_t msg;
    msg_t msg_queue[4];
    msg_init_queue(msg_queue, 4);

    puts("[umdk-" _UMDK_NAME_ "] Periodic publisher thread started");

    while (1) {
        msg_receive(&msg);

        module_data_t data = {};
        data.as_ack = is_polled;
        is_polled = false;

        prepare_result(&data);

        /* Notify the application */
        callback(&data);

        /* Restart after delay */
        rtctimers_millis_set_msg(&timer, 1000 * gassensor_config.publish_period_sec, &timer_msg, timer_pid);
    }

    return NULL;
}

static void set_period (int period) {
    gassensor_config.publish_period_sec = period;
    save_config();

    /* Don't restart timer if new period is zero */
    if (gassensor_config.publish_period_sec) {
        rtctimers_millis_set_msg(&timer, 1000 * gassensor_config.publish_period_sec, &timer_msg, timer_pid);
        printf("[umdk-" _UMDK_NAME_ "] Period set to %d minutes\n", gassensor_config.publish_period_sec);
    } else {
        puts("[umdk-" _UMDK_NAME_ "] Timer stopped");
    }
}

int umdk_gassensor_shell_cmd(int argc, char **argv) {
    if (argc == 1) {
        puts (_UMDK_NAME_ " get - get results now");
        puts (_UMDK_NAME_ " send - get and send results now");
        puts (_UMDK_NAME_ " period <N> - set period to N minutes");
        puts (_UMDK_NAME_ " sensor <type> - set sensor type (H2S, CO, O3, NO2, SO2)");
        puts (_UMDK_NAME_ " code <value> - set sensor sensitivity code pA/ppm");
        puts (_UMDK_NAME_ " reset - reset settings to default");
        return 0;
    }
    
    char *cmd = argv[1];

    if (strcmp(cmd, "get") == 0) {
        prepare_result(NULL);
    }
    
    if (strcmp(cmd, "send") == 0) {
        /* Send signal to publisher thread */
        msg_send(&timer_msg, timer_pid);
    }
    
    if (strcmp(cmd, "period") == 0) {
        char *val = argv[2];
        set_period(atoi(val));
    }
    
    if (strcmp(cmd, "reset") == 0) {
        reset_config();
        save_config();
    }
    
    if (strcmp(cmd, "sensor") == 0) {
        char *val = argv[2];

        printf("%s\n", argv[2]);

        if (strcmp(val, "H2S") == 0) {
            puts("Set sensor type is H2S");
            gassensor_config.sensor_type = UMDK_GASSENSOR_H2S;
            save_config();
        } else if (strcmp(val, "CO") == 0) {
            puts("Set sensor type is CO");
            gassensor_config.sensor_type = UMDK_GASSENSOR_CO;
            save_config();
        } else if (strcmp(val, "O3") == 0) {
            puts("Set sensor type is O3");
            gassensor_config.sensor_type = UMDK_GASSENSOR_O3;
            save_config();
        } else if (strcmp(val, "NO2") == 0) {
            puts("Set sensor type is NO2");
            gassensor_config.sensor_type = UMDK_GASSENSOR_NO2;
            save_config();
        } else if (strcmp(val, "SO2") == 0) {
            puts("Set sensor type is SO2");
            gassensor_config.sensor_type = UMDK_GASSENSOR_SO2;
            save_config();
        } else {
            puts("Set sensor type is unknown");
            gassensor_config.sensor_type = UMDK_GASSENSOR_UNKNOWN;
            save_config();
        }
    }

    if (strcmp(cmd, "code") == 0) {
        char *val = argv[2];
        
        gassensor_config.sensor_code = atoi(val);
        save_config();
    }
    
    return 1;
}

void umdk_gassensor_init(uwnds_cb_t *event_callback)
{

    callback = event_callback;
    init_config();

    init_gassensor();

    /* Create handler thread */
    char *stack = (char *) allocate_stack(UMDK_GASSENSOR_STACK_SIZE);
    if (!stack) {
        return;
    }

    unwds_add_shell_command( _UMDK_NAME_, "type '" _UMDK_NAME_ "' for commands list", umdk_gassensor_shell_cmd);

    timer_pid = thread_create(stack, UMDK_GASSENSOR_STACK_SIZE, THREAD_PRIORITY_MAIN - 1, THREAD_CREATE_STACKTEST, timer_thread, NULL, "ADC thread");

    /* Start publishing timer */
    rtctimers_millis_set_msg(&timer, 1000 * gassensor_config.publish_period_sec, &timer_msg, timer_pid);
}

static void reply_ok(module_data_t *reply)
{
    reply->length = 4;
    reply->data[0] = _UMDK_MID_;
    reply->data[1] = UMDK_GASSENSOR_CMD_COMMAND;
    reply->data[2] = gassensor_config.publish_period_sec;
}

static void reply_fail(module_data_t *reply)
{
    reply->length = 2;
    reply->data[0] = _UMDK_MID_;
    reply->data[1] = UMDK_GASSENSOR_FAIL;
}

bool umdk_gassensor_cmd(module_data_t *cmd, module_data_t *reply)
{
    if (cmd->length < 1) {
        reply_fail(reply);
        return true;
    }

    umdk_gassensor_cmd_t c = cmd->data[0];
    switch (c) {
        case UMDK_GASSENSOR_CMD_COMMAND: {
            /* leave it empty for a while */

            reply_ok(reply);
            break;
        }

        case UMDK_GASSENSOR_CMD_POLL:
            is_polled = true;

            /* Send signal to publisher thread */
            msg_send(&timer_msg, timer_pid);

            return false; /* Don't reply */

            break;
            
        default:
            reply_fail(reply);
            break;
    }

    return true;
}

#ifdef __cplusplus
}
#endif
