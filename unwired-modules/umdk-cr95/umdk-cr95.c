/*
 * Copyright (C) 2018 Unwired Devices [info@unwds.com]
 *
 * This file is subject to the terms and conditions of the GNU Lesser
 * General Public License v2.1. See the file LICENSE in the top level
 * directory for more details.
 */

/**
 * @defgroup
 * @ingroup
 * @brief
 * @{
 * @file		umdk-cr95.c
 * @brief       umdk-cr95 module implementation
 * @author      Mikhail Perkov

 */

#ifdef __cplusplus
extern "C" {
#endif

/* define is autogenerated, do not change */
#undef _UMDK_MID_
#define _UMDK_MID_ UNWDS_CR95_MODULE_ID

/* define is autogenerated, do not change */
#undef _UMDK_NAME_
#define _UMDK_NAME_ "cr95"

#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <limits.h>

#include "periph/gpio.h"
#include "periph/spi.h"
#include "periph/uart.h"
#include "board.h"

#include "unwds-common.h"
#include "include/umdk-cr95.h"

#include "thread.h"
#include "xtimer.h"
#include "rtctimers-millis.h"

#define ENABLE_DEBUG 0
#include "debug.h"

static msg_t msg_rx;

static cr95_params_t cr95_params = { .spi = UMDK_CR95_SPI_DEV, .cs_spi = UMDK_CR95_SPI_CS, \
									 .uart = UMDK_CR95_UART_DEV, \
									 .irq_in = UMDK_CR95_IRQ_IN, .irg_out = UMDK_CR95_IRQ_OUT, \
									 .ssi_0 = UMDK_CR95_SSI_0, .ssi_1 = UMDK_CR95_SSI_1 };
static kernel_pid_t radio_pid;
static uwnds_cb_t *callback;

static uint8_t rxbuf[30];
static uint8_t txbuf[30];
static uint8_t txbuf_tmp[30];

static volatile uint8_t num_bytes_rx = 0;
static volatile uint8_t uart_rx = 0;

static uint8_t current_cmd = 0;
static uint8_t flag_detect = 0;

static uint8_t (*cr95_iface)(uint8_t) = NULL;
static uint8_t iface = UMDK_CR95_IFACE_UART;
static uint8_t protocol = 0;

static uint8_t uart_irq_debug = 0;

static uint32_t time1 = 0;
static uint32_t time2 = 0;

static uint8_t _send_uart(uint8_t length);
static uint8_t _send_recv_spi(uint8_t length);
// static void _reset_spi(void);
static uint8_t _send_pack(uint8_t len);
static uint8_t _cmd_echo(void);
static uint8_t _idn_cmd(void);
static uint8_t _cr95_select_iface(uint8_t iface);
// static uint8_t _cr95_wake_up(void);

// static uint8_t _select_protocol(void);
static uint8_t _select_iso15693(void);
// static uint8_t _select_field_off(void);
static uint8_t _select_iso14443a(void);
static uint8_t _select_iso14443b(void);
static uint8_t _select_iso18092(void);

static uint8_t _send_receive(uint8_t * data, uint8_t length);
void _send_IRQIN_NegativePulse(void);

static uint8_t _select_protocol(void)
{
	if(protocol & ISO14443A_SELECT) {
		puts("		[ ISO 14443 A ]");
		_send_pack(_select_iso14443a());	
	}
	if(protocol & ISO14443B_SELECT) {
		puts("		[ ISO 14443 B ]");
		// _send_pack(_select_iso14443b());	
	}
	if(protocol & ISO15693_SELECT) {
		puts("		[ ISO 15693 ]");
		// _send_pack(_select_iso15693());	
	}
	if(protocol & ISO18092_SELECT) {
		puts("		[ ISO 18092 ]");
		_select_iso18092();
		// _send_pack(_select_iso18092());	
	}
	
	if(protocol == NO_SELECT_PROTOCOL) {
		puts("No selected protocol");
		return 0;
	}
	
	return 1;
}

static uint8_t _send_receive(uint8_t * data, uint8_t length)
{
	txbuf[0] = 0x00;
	
	txbuf[1] = CR95_CMD_SEND_RECV;
	txbuf[2] = length;
	memcpy(txbuf + 3, data, length);
	// txbuf[3] = 0x26;
	// txbuf[4] = 0x07;
	
	return (3 + length);
}


// static void _reset_spi(void)
// {
	// spi_acquire(SPI_DEV(cr95_params.spi), cr95_params.cs_spi, SPI_MODE_0, SPI_CLK_1MHZ);
		/*Send Reset*/
	// tx_spi = 0x01;
	// spi_transfer_bytes(SPI_DEV(cr95_params.spi), cr95_params.cs_spi, false, &tx_spi, &rx_reset, 1);

	// spi_release(SPI_DEV(cr95_params.spi));
	
	// rtctimers_millis_sleep(20);	
	// _send_IRQIN_NegativePulse();
// }

void _send_IRQIN_NegativePulse(void)
{
	// gpio_init(UMDK_CR95_IRQ_IN, GPIO_OUT);
	gpio_set(UMDK_CR95_IRQ_IN);
	xtimer_usleep(1000);
	gpio_clear(UMDK_CR95_IRQ_IN);
	xtimer_usleep(1000);
	gpio_set(UMDK_CR95_IRQ_IN);
	// gpio_init_af(UMDK_CR95_IRQ_IN, GPIO_AF7);
}

static uint8_t _idn_cmd(void)
{
	current_cmd = CR95_CMD_IDN;
	
	txbuf[0] = 0x00;
	
	txbuf[1] = CR95_CMD_IDN;
	txbuf[2] = 0x00;
	
	return 3;
}

// static uint8_t _select_field_off(void)
// {
	
// }

static uint8_t _select_iso18092(void)
{
	return 0;
}

static uint8_t _select_iso15693(void)
{
	txbuf[0] = 0x00;
	
	txbuf[1] = CR95_CMD_PROTOCOL;
	txbuf[2] = 2;// Length
	
	txbuf[3] = ISO_15693;
	txbuf[4] = 0x05;
	
	return 5;
}

static uint8_t _select_iso14443a(void)
{
	txbuf[0] = 0x00;
	
	txbuf[1] = CR95_CMD_PROTOCOL;
	txbuf[2] = 2;// Length
	
	txbuf[3] = ISO_14443A;
	txbuf[4] = 0x00 | (TX_RATE_106 << 6) | (RX_RATE_106 << 4);	// (TX_RATE << 6) | (RX_RATE << 4) // 02

	txbuf[5] = 0x00;	// PP (Optioanal) 															// 00
	txbuf[6] = 0x00;	// MM (Optioanal)															// 01
	txbuf[7] = 0x00;	// DD (Optioanal)															// 80
	txbuf[8] = 0x00;	// ST Reserved (Optioanal)
	txbuf[9] = 0x00;	// ST Reserved (Optioanal)

	return 5;
}

static uint8_t _select_iso14443b(void)
{
	txbuf[0] = 0x00;
	
	txbuf[1] = CR95_CMD_PROTOCOL;
	txbuf[2] = 2;// Length
	
	txbuf[3] = ISO_14443B;
	// txbuf[4] = 0x00 | (TX_RATE_106 << 6) | (RX_RATE_106 << 4);	// (TX_RATE << 6) | (RX_RATE << 4) // 02
txbuf[4] = 0x01;


	txbuf[5] = 0x00;	// PP (Optioanal) 															// 00
	txbuf[6] = 0x00;	// MM (Optioanal)															// 01
	txbuf[7] = 0x00;	// DD (Optioanal)															// 80
	txbuf[8] = 0x00;	// ST Reserved (Optioanal)
	txbuf[9] = 0x00;	// ST Reserved (Optioanal)

	return 5;
}

static uint8_t _send_pack(uint8_t len)
{	
	return ((*cr95_iface)(len));
}

static uint8_t _cr95_select_iface(uint8_t iface)
{		
	if(iface == UMDK_CR95_IFACE_UART) {		
		gpio_clear(UMDK_CR95_SSI_0);
		cr95_iface = &_send_uart;
	
		uart_rx = 1;
			/* disable SPI device */
		// spi_release(SPI_DEV(cr95_params.spi));
		
		puts("[umdk-" _UMDK_NAME_ "] Using UART interface");
		// rtctimers_millis_sleep(15);
	}
	else if(iface == UMDK_CR95_IFACE_SPI) {		
		gpio_set(UMDK_CR95_SSI_0);
		cr95_iface = &_send_recv_spi;

		uart_rx = 0;
			/* disable UART device */
		// uart_poweroff(UART_DEV(cr95_params.uart));
		
		puts("[umdk-" _UMDK_NAME_ "] Using SPI interface");
		// xtimer_usleep(100);
	}
	else {
		puts("[umdk-" _UMDK_NAME_ "] Error selecting interface");
		return 0;
	}
		rtctimers_millis_sleep(10);
	return 1;
}

static uint8_t _cmd_echo(void)
{
	current_cmd = CR95_CMD_ECHO;
	txbuf[0] = 0x00;
	txbuf[1] = CR95_CMD_ECHO;
	
	_send_pack(2);
	
	if((rxbuf[0] != CR95_CMD_ECHO) && (rxbuf[1] != CR95_CMD_ECHO)) {
		return 0;
	}
	
	rxbuf[0] = 0x00;
	rxbuf[1] = 0x00;
	return 1;
}

static void *radio_send(void *arg)
{
    (void) arg;
    msg_t msg;
    msg_t msg_queue[16];
    msg_init_queue(msg_queue, 16);

	while (1) {
        msg_receive(&msg);
		uint32_t time = xtimer_now_usec();
		printf("Time RX: %ld\n", time - time2);
		printf("Time Full RX: %ld\n", time - time1);
		printf("RX data[%d]: ", num_bytes_rx);
		
		for(uint32_t i = 0; i < num_bytes_rx; i++) {
				printf(" %02X", rxbuf[i]);
			}	
		
		printf("\n\n");
		
		num_bytes_rx = 0;
		
		if(current_cmd == CR95_CMD_IDLE) {
			if(rxbuf[2] == 0x02) {
				flag_detect = 1;
				puts("[DETECT]");
			}
			else {
				puts("[NOT DETECT]");
			}
			
			
		// if(rxbuf[0] == 0x80) {
			// printf("CARD: 0x");
		
		// for(uint32_t i = 2; i < 6; i++) {
				// printf("%02X ", rxbuf[i]);
			// }	
					// printf("\n\n");
		// }
		}
		
		
		// if(current_cmd == CR95_CMD_IDLE) {
			// current_cmd = 0;
			
			// if(!_select_protocol()) {
	// }
			
			// uint8_t send_1a[2] = {0x26, 0x07};
	// uint8_t send_2a[3] = {0x93, 0x20, 0x08};
	// num_bytes_rx = 0;
	// _send_pack(_send_receive(send_1a, 2));
	// num_bytes_rx = 0;
	// _send_pack(_send_receive(send_2a, 3));
		// }
		
		current_cmd = 0;
		
		// memset(rxbuf, 0x00, num_bytes_rx);
    }
    return NULL;
}

// static void reset_config(void) {
	// umdk_modbus_config.baudrate = UMDK_MODBUS_BAUDRATE_DEF;
    // umdk_modbus_config.databits = UART_DATABITS_8;
    // umdk_modbus_config.parity = UART_PARITY_NOPARITY;
    // umdk_modbus_config.stopbits = UART_STOPBITS_20;
	// umdk_modbus_config.uart_dev = UMDK_UART_DEV;
// }

void cr95_uart_rx(void *arg, uint8_t data)
{
	(void) arg;
	if(uart_irq_debug == 1) puts("			IRQ");
	if(uart_rx == 0) {
		puts("RX UART NOT ALLOW");
		num_bytes_rx = 0;
		return;
	}
	
	if(num_bytes_rx >= 30) {
		puts("OVERFLOW");
		return;
	}
	
	rxbuf[num_bytes_rx] = data;
	num_bytes_rx++;
	
	if(current_cmd == CR95_CMD_ECHO) {
		// puts("UART MSG ECHO");
		msg_try_send(&msg_rx, radio_pid);
		return;
	}
	
	if(num_bytes_rx >= 2) {
		if((num_bytes_rx - 2) == rxbuf[1]) {
			// puts("UART MSG");
			time2 = xtimer_now_usec();
			msg_try_send(&msg_rx, radio_pid);
		}
	}
	
	return;
}

static uint8_t _send_uart(uint8_t length)
{
	printf("UART[%d] -> ", length - 1);
	for(uint8_t i = 0; i < length - 1; i++) {
		if(i == 1) printf("  [ ");
		printf(" %02X", txbuf[i + 1]);
		if(i == 1) printf(" ]   ");
	}
	printf("\n");
	
    uart_write(UART_DEV(cr95_params.uart), txbuf + 1, length - 1);
	
	rtctimers_millis_sleep(50);
	
	return 1;
}

static uint8_t _send_recv_spi(uint8_t length) 
{
	uint8_t tx_spi;
	uint8_t rx_poll = 0;
	// uint8_t rx_data = 0;
	uint32_t cnt_poll = 0;
	//****************
	
printf("SPI[%d] -> ", length );
	for(uint8_t i = 0; i < length; i++) {
		if(i == 2) printf("  [ ");
		printf(" %02X", txbuf[i]);
		if(i == 2) printf(" ]   ");
	}
	printf("\n");
	
	memset(rxbuf, 0x00, 25);
	spi_acquire(SPI_DEV(cr95_params.spi), cr95_params.cs_spi, SPI_MODE_0, SPI_CLK_1MHZ);
	
	/*Send command*/
	tx_spi = 0x00;
	spi_transfer_bytes(SPI_DEV(cr95_params.spi), cr95_params.cs_spi, true, &tx_spi, NULL, 1);
	spi_transfer_bytes(SPI_DEV(cr95_params.spi), cr95_params.cs_spi, false, txbuf + 1, NULL, length - 1);
	
	/*Send polling*/
	tx_spi = 0x03;
	while(rx_poll != 0x08) {		
		spi_transfer_bytes(SPI_DEV(cr95_params.spi), cr95_params.cs_spi, true, &tx_spi, NULL, 1);
		spi_transfer_bytes(SPI_DEV(cr95_params.spi), cr95_params.cs_spi, false, &tx_spi, &rx_poll, 1);	
		rx_poll &= 0xF8;	
		cnt_poll++;
		if(cnt_poll > 100000) {
			puts("			[ NOT POLLING ]");
			break;
		}
	}
	
	/*Read data*/
	tx_spi = 0x02;	
				// if(current_cmd == CR95_CMD_ECHO){
					// spi_transfer_bytes(SPI_DEV(cr95_params.spi), cr95_params.cs_spi, true, &tx_spi, NULL, 1);
							// spi_transfer_bytes(SPI_DEV(cr95_params.spi), cr95_params.cs_spi, true, &tx_spi, NULL, 1);
							// spi_transfer_bytes(SPI_DEV(cr95_params.spi), cr95_params.cs_spi, false, NULL, &rx_data, 1);
					// num_bytes_rx = 1;
					// rxbuf[0] = rx_data;
				// }
				// else {
					// txbuf_tmp[0] = tx_spi;

							// spi_transfer_bytes(SPI_DEV(cr95_params.spi), cr95_params.cs_spi, true, &tx_spi, NULL, 1);
							// spi_transfer_bytes(SPI_DEV(cr95_params.spi), cr95_params.cs_spi, false, NULL, rxbuf, 20);
					// spi_transfer_bytes(SPI_DEV(cr95_params.spi), cr95_params.cs_spi, false, txbuf_tmp, rxbuf, 25);
					// num_bytes_rx = 25;
				// }
	
	
	txbuf_tmp[0] = tx_spi;
	spi_transfer_bytes(SPI_DEV(cr95_params.spi), cr95_params.cs_spi, false, txbuf_tmp, rxbuf, 25);
	num_bytes_rx = 25;
	
	/*Send Reset*/
	// tx_spi = 0x01;
	// spi_transfer_bytes(SPI_DEV(cr95_params.spi), cr95_params.cs_spi, false, &tx_spi, &rx_reset, 1);

	spi_release(SPI_DEV(cr95_params.spi));
	
	// rtctimers_millis_sleep(20);	
	// _send_IRQIN_NegativePulse();
	
	// printf("POLLING[%d]: %02X\n  ", cnt_poll, rx_poll);
		/* Schedule sending after timeout */
	msg_send(&msg_rx, radio_pid);
	xtimer_usleep(15);
	
	return 1;
}

void umdk_cr95_init(uint32_t *non_gpio_pin_map, uwnds_cb_t *event_callback)
{
	(void)non_gpio_pin_map;

	callback = event_callback;
	
	memset(txbuf, 0x00, 30);
	memset(rxbuf, 0x00, 30);

	/* Initialize the UART params*/
    uart_params_t params;
    params.baudrate = UMDK_CR95_UART_BAUD_DEF;
    params.databits = UART_DATABITS_8;
    params.parity = UART_PARITY_NOPARITY;
    params.stopbits = UART_STOPBITS_10;
	
	gpio_init(UMDK_CR95_SSI_0, GPIO_OUT);
	
	gpio_clear(UMDK_CR95_SSI_0);	// UART - default
	// gpio_set(UMDK_CR95_SSI_0);	// SPI
	
	gpio_init(UMDK_CR95_IRQ_IN, GPIO_OUT);
		/* Set low level IRQ_IN/RX */
	gpio_set(UMDK_CR95_IRQ_IN);
	rtctimers_millis_sleep(10);
	gpio_clear(UMDK_CR95_IRQ_IN);
	rtctimers_millis_sleep(10);
	gpio_init_af(UMDK_CR95_IRQ_IN, GPIO_AF7);
	
	/* Initialize UART */
    if (uart_init_ext(UART_DEV(cr95_params.uart), &params, cr95_uart_rx, NULL)) {
		return;
    }
	else {
		printf("[umdk-" _UMDK_NAME_ "] Init UART interface: %02d \n", cr95_params.uart);
	}
		
	 /* Initialize SPI */
	spi_init(SPI_DEV(cr95_params.spi));
	 /* Initialize CS SPI */
	if(spi_init_cs(SPI_DEV(cr95_params.spi), cr95_params.cs_spi) == SPI_OK) {
		printf("[umdk-" _UMDK_NAME_ "] Init SPI interface: %02d\n", cr95_params.spi);
	}
	else {
		return;
	}
		 
	 /* Create handler thread */
    char *stack = (char *) allocate_stack(UMDK_CR95_STACK_SIZE);
    if (!stack) {
        puts("[umdk-" _UMDK_NAME_ "] unable to allocate memory. Is too many modules enabled?");
        return;
    }
	
	radio_pid = thread_create(stack, UMDK_CR95_STACK_SIZE, THREAD_PRIORITY_MAIN - 1, THREAD_CREATE_STACKTEST, radio_send, NULL, "cr95 thread");
	uart_rx = 1;	
	
		iface = UMDK_CR95_IFACE_UART;
	// iface = UMDK_CR95_IFACE_SPI;
	
	if(!_cr95_select_iface(iface)) {
		return;
	}
	
	if(!_cmd_echo()) {
		puts("NO DEVICE FOUND");
		return;
	}
	
	protocol = ISO14443A_SELECT;
	
	if(!_select_protocol()) {
		puts("No selected protocol");
		return;
	}
	
	
				// uint8_t sel_14443[8] = { 0x00, 0x02, 0x04, 0x02, 0x00, 0x01, 0x80};	
				// memcpy(txbuf, sel_14443, 7);
				// _send_uart(7);
				// rtctimers_millis_sleep(15);
				
				time1 = xtimer_now_usec();
uint8_t send_1a[2] = {0x26, 0x07};
uint8_t send_2a[3] = {0x93, 0x20, 0x08};
	
uint8_t send_r1[6] = {0x00, 0x09, 0x03, 0x68, 0x00, 0x01};
uint8_t send_r2[6] = {0x00, 0x08, 0x03, 0x69, 0x01, 0x00};
	
	// memcpy(txbuf, send_r1, 6);
	// _send_uart(6);
	// memcpy(txbuf, send_r2, 6);
	// _send_uart(6);
	
	puts("			[ GET UID ]");
	_send_pack(_send_receive(send_1a, 2));
	_send_pack(_send_receive(send_2a, 3));
	
			rtctimers_millis_sleep(150);
	puts("********************************************");
	
		rtctimers_millis_sleep(5000);
	// _select_protocol();
	
uint8_t send_w1[7] = {0x00, 0x09, 0x04, 0x3A, 0x00, 0x58, 0x04};
uint8_t send_w2[7] = {0x00, 0x09, 0x04, 0x68, 0x01, 0x01, 0xD1};	
	memcpy(txbuf, send_w1, 7);
	_send_uart(7);
	memcpy(txbuf, send_w2, 7);
	_send_uart(7);

	memcpy(txbuf, send_r1, 6);
	_send_uart(6);
	memcpy(txbuf, send_r2, 6);
	_send_uart(6);
	
	puts("			[ GET UID ]");

	_send_pack(_send_receive(send_1a, 2));
	_send_pack(_send_receive(send_2a, 3));
	// uint8_t thisdata[16] = {0x07, 0x0E, 0x03, 0x21, 0x00,  0x79, 0x01, 0x18, 0x00, 
							// 0x02, 0x60, 0x60, 0x00, 0x00, 0x3F, 0x01};
	/* Step 0 */
	// uint8_t tag_cmd[17] = {0x00, 0x07, 0x0E, 0x03, 0x21, 0x00, 0x79, 0x01, 0x18, 0x00, 
							// 0x02, 0x60, 0x60, 0x00, 0x00, 0x3F, 0x01};	
	// memcpy(txbuf, tag_cmd, 17);
	// _send_uart(17); 
	
	// tag_cmd[14] = 0xFE;
	// while(tag_cmd[14] > 0x06) {
		// tag_cmd[14] -= 0x04;
	// memcpy(txbuf, tag_cmd, 17);
	// _send_uart(17); 
	// }
	
		// tag_cmd[14] = 0x42;
	 // tag_cmd[17] = {0x00, 0x07, 0x0E, 0x03, 0x21, 0x00, 0x79, 0x01, 0x18, 0x00, 0x20, 0x60, 0x60, 0x00, 0x42, 0x3F, 0x01};	
	// memcpy(txbuf, tag_cmd, 17);
	// _send_uart(17); 
	
	// uint8_t send_r3[6] = {0x00, 0x08, 0x03, 0x62, 0x01, 0x00};
	// memcpy(txbuf, send_r3, 6);
	// _send_uart(6); 
	
	
	// uint8_t send_w1[7] = {0x00, 0x09, 0x04, 0x3A, 0x00, 0x58, 0x04};
// uint8_t send_w2[7] = {0x00, 0x09, 0x04, 0x68, 0x01, 0x01, 0xD1};
	
	// memcpy(txbuf, send_w1, 7);
	// _send_uart(7);
	
	// memcpy(txbuf, send_w2, 7);
	// _send_uart(7);
	
	puts("*******************  SLEEP  *************************");
	flag_detect = 0;
	current_cmd = CR95_CMD_IDLE;
	uint8_t idle_cmd[17] = {0x00, 0x07, 0x0E, 0x02, 0x21, 0x00, 0x79, 0x01, 0x18, 0x00, 0x20, 0x60, 0x60, 0x42, 0xFC, 0x3F, 0x08};	
	memcpy(txbuf, idle_cmd, 17);
	_send_uart(17); 

	for(uint32_t i = 0; i < 3000; i++) {	
		if(flag_detect == 0) {
			rtctimers_millis_sleep(100);			
		}
		else {
			break;
		}
	}	
	
	_select_protocol();
	
	// memcpy(txbuf, send_r1, 6);
	// _send_uart(6);
	// memcpy(txbuf, send_r2, 6);
	// _send_uart(6);
	
	
	puts("			[ GET UID ]");
	_send_pack(_send_receive(send_1a, 2));
	_send_pack(_send_receive(send_2a, 3));

}

// static inline void reply_code(module_data_t *reply, cr95_reply_t code) 
// {
	// reply->as_ack = true;
	// reply->length = 2;
	// reply->data[0] = _UMDK_MID_;
	// reply->data[1] = code;
// }


bool umdk_cr95_cmd(module_data_t *cmd, module_data_t *reply)
{	
memset(txbuf, 0x00, 30);
	memset(rxbuf, 0x00, 30);
uart_irq_debug = 0;
	printf("CMD: %02X  ", cmd->data[0]);
	for(uint32_t i = 1; i < cmd->length; i++) {
		printf(" %02X", cmd->data[i]);
	}
	printf("\n");

	if(cmd->length == 1) {
		if(!_cr95_select_iface(cmd->data[0])) {
			puts("Error iface");
			// return true;
		}
		// return false;
	}

	// if(uart_rx == 1) {
		
	// rtctimers_millis_sleep(10);
	 // _send_pack(_idn_cmd());
	 	 // rtctimers_millis_sleep(10);
	 _send_pack(_cmd_echo());
		
	// }
	
	_send_pack(_idn_cmd());
	
	return false;
	
	if(!_select_protocol()) {
		puts("No selected protocol");
	}
	
	_send_receive(txbuf, 0);
_select_iso14443a();
_select_iso14443b();
_select_iso15693();

	reply->as_ack = true;	
	reply->length = 1;
	reply->data[0] = _UMDK_MID_;
	
	return true; /* Allow reply */
}


#ifdef __cplusplus
}
#endif
