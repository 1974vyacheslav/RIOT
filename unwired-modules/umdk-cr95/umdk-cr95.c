/*
 * Copyright (C) 2018 Unwired Devices [info@unwds.com]
 *
 * This file is subject to the terms and conditions of the GNU Lesser
 * General Public License v2.1. See the file LICENSE in the top level
 * directory for more details.
 */

/**
 * @defgroup
 * @ingroup
 * @brief
 * @{
 * @file		umdk-cr95.c
 * @brief       umdk-cr95 module implementation
 * @author      Mikhail Perkov

 */

#ifdef __cplusplus
extern "C" {
#endif

/* define is autogenerated, do not change */
#undef _UMDK_MID_
#define _UMDK_MID_ UNWDS_CR95_MODULE_ID

/* define is autogenerated, do not change */
#undef _UMDK_NAME_
#define _UMDK_NAME_ "cr95"

#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <limits.h>

#include "periph/gpio.h"
#include "periph/spi.h"
#include "periph/uart.h"
#include "board.h"

#include "unwds-common.h"
#include "include/umdk-cr95.h"

#include "thread.h"
#include "xtimer.h"
#include "rtctimers-millis.h"

#define ENABLE_DEBUG 1
#include "debug.h"

static msg_t msg_rx;

static umdk_cr95_config_t umdk_cr95_config = { CR95_IFACE_UART, CR95_READER, ISO14443A_SELECT };

static cr95_params_t cr95_params = { .spi = UMDK_CR95_SPI_DEV, .cs_spi = UMDK_CR95_SPI_CS, \
									 .uart = UMDK_CR95_UART_DEV, \
									 .irq_in = UMDK_CR95_IRQ_IN, .irg_out = UMDK_CR95_IRQ_OUT, \
									 .ssi_0 = UMDK_CR95_SSI_0, .ssi_1 = UMDK_CR95_SSI_1 };
static kernel_pid_t radio_pid;
// static uwnds_cb_t *callback;
static rtctimers_millis_t detect_timer;

static xtimer_t rx_timer;

static uint8_t rxbuf[30];
static uint8_t txbuf[30];

static uint8_t dac_data_h = 0x00;
static uint8_t dac_data_l = 0x00;

static volatile uint8_t num_bytes_rx = 0;
static volatile uint8_t uart_rx = 0;

static uint8_t current_cmd = 0;

static uint8_t (*cr95_iface)(uint8_t) = NULL;

static uint8_t protocol = 0;
static uint8_t offset = 0;

static volatile cr95_pack_state_t current_state = UMDK_CR95_PACK_ERROR;
static volatile cr95_rx_state_t flag_rx = UMDK_CR95_NOT_RECIEVED;

	uint8_t send_1a[2] = {0x26, 0x07};
	uint8_t send_2a[3] = {0x93, 0x20, 0x08};
	
	uint8_t send_data[10] = {0x80, 0x08, 0x90, 0xAB, 0x85, 0xD7, 0x69, 0x28, 0x00, 0x00 };

static uint8_t cr95_select_iface(uint8_t iface);	
	
static uint8_t send_pack(uint8_t len);
static uint8_t _send_uart(uint8_t length);
static uint8_t _send_spi(uint8_t length);

// static uint32_t t1 = 0;
// static uint32_t t2 = 0; 


// static void _reset_spi(void);
static uint8_t _cmd_echo(void);
static uint8_t _cmd_idn(void);
static uint8_t _cmd_idle(void);
static uint8_t _calibration(void);

static uint8_t _cmd_select_protocol(void);
static uint8_t _select_iso15693(void);
static uint8_t _select_field_off(void);
static uint8_t _select_iso14443a(void);
static uint8_t _select_iso14443b(void);
static uint8_t _select_iso18092(void);

static uint8_t _cmd_send_receive(uint8_t * data, uint8_t length);
void _send_IRQIN_NegativePulse(void);

static bool _check_pack(uint8_t length);

static void detect_handler(void *arg) 
{
	(void) arg;
	
	// t1 = xtimer_now_usec();
	
	memset(rxbuf, 0x00, sizeof(rxbuf));
	current_cmd = CR95_CMD_IDLE;

	flag_rx = UMDK_CR95_NOT_RECIEVED;
	current_state = UMDK_CR95_PACK_ERROR;

	_cmd_idle();
}

static uint8_t _cmd_select_protocol(void)
{
	msg_rx.type = UMDK_CR95_MSG_PROTOCOL;
	current_cmd = CR95_CMD_PROTOCOL;
	
	if(protocol & ISO14443A_SELECT) {
		// puts("		[ ISO 14443 A ]");
		_select_iso14443a();
	}
	if(protocol & ISO14443B_SELECT) {
		puts("		[ ISO 14443 B ]");
		// _select_iso14443b();	
	}
	if(protocol & ISO15693_SELECT) {
		puts("		[ ISO 15693 ]");
		// _select_iso15693();	
	}
	if(protocol & ISO18092_SELECT) {
		puts("		[ ISO 18092 ]");
		_select_iso18092();
	}
	
	if(protocol == NO_SELECT_PROTOCOL) {
		puts("No selected protocol");
		return 0;
	}

	return 1;
}

static uint8_t _cmd_send_receive(uint8_t * data, uint8_t length)
{	
	current_cmd = CR95_CMD_SEND_RECV;
	
	// uint8_t length = 0;
	txbuf[0] = CR95_CMD_SEND_RECV;
	txbuf[1] = length;
	memcpy(txbuf + 2, data, length);
	
	send_pack(2 + length);
	
	return 1;
}

static uint8_t _cmd_idle(void)
{	

puts("IDLE");
	msg_rx.type = UMDK_CR95_MSG_IDLE;
	
	txbuf[0] = CR95_CMD_IDLE;	// Command
	txbuf[1] = 14;				// Data Length 
	/* Idle params */
		/* Wake Up Source */
	txbuf[2] = 0x02;			// Tag Detection
		/* Enter Control (the resources when entering WFE mode)*/
	txbuf[3] = 0x21;			// Tag Detection
	txbuf[4] = 0x00;			// 
		/* Wake Up Control (the wake-up resources) */
	txbuf[5] = 0x79;			// Tag Detection
	txbuf[6] = 0x01;			//
		/* Leave Control (the resources when returning to Ready state)*/
	txbuf[7] = 0x18;			// Tag Detection
	txbuf[8] = 0x00;			//
		/* Wake Up Period (the time allowed between two tag detections) */
	txbuf[9] = 0x20;			// Typical value 0x20
		/* Osc Start (the delay for HFO stabilization) */
	txbuf[10] = 0x60;			// Recommendeded value 0x60
		/* DAC Start (the delay for DAC stabilization) */
	txbuf[11] = 0x60;			// Recommendeded value 0x60
		/* DAC Data */
	txbuf[12] = dac_data_l; 	//0x42;			// DacDataL
	txbuf[13] = dac_data_h; 	//0xFC;			// DacDataH
		/* Swing Count */
	txbuf[14] = 0x3F;			// Recommendeded value 0x3F
		/* Max Sleep */
	txbuf[15] = 0x08;			// Typical value 0x28
	
	send_pack(16);
	
	return 1;
}


// static void _reset_spi(void)
// {
	// spi_acquire(SPI_DEV(cr95_params.spi), cr95_params.cs_spi, SPI_MODE_0, SPI_CLK_1MHZ);
		/*Send Reset*/
	// tx_spi = 0x01;
	// spi_transfer_bytes(SPI_DEV(cr95_params.spi), cr95_params.cs_spi, false, &tx_spi, &rx_reset, 1);

	// spi_release(SPI_DEV(cr95_params.spi));
	
	// rtctimers_millis_sleep(20);	
	// _send_IRQIN_NegativePulse();
// }

void _send_IRQIN_NegativePulse(void)
{
	// gpio_init(UMDK_CR95_IRQ_IN, GPIO_OUT);
	gpio_set(UMDK_CR95_IRQ_IN);
	xtimer_usleep(1000);
	gpio_clear(UMDK_CR95_IRQ_IN);
	xtimer_usleep(1000);
	gpio_set(UMDK_CR95_IRQ_IN);
	// gpio_init_af(UMDK_CR95_IRQ_IN, GPIO_AF7);
}

static uint8_t _cmd_idn(void)
{
	current_cmd = CR95_CMD_IDN;
	msg_rx.type = UMDK_CR95_MSG_IDN;
	
	txbuf[0] = CR95_CMD_IDN;
	txbuf[1] = 0x00;
	
	send_pack(2);
	
	return 1;
}

static uint8_t _select_field_off(void)
{
	msg_rx.type = UMDK_CR95_MSG_PROTOCOL;
	
	txbuf[0] = CR95_CMD_PROTOCOL;
	txbuf[1] = 2;
	txbuf[2] = FIELD_OFF;
	txbuf[3] = 0x00;
	
	send_pack(4);
	
	return 1;
}

static uint8_t _select_iso18092(void)
{
	uint8_t length  = 0;
	
	txbuf[0] = CR95_CMD_PROTOCOL;
	txbuf[1] = 2;	// Data Length
	
	txbuf[2] = ISO_18092;
	
	// txbuf[3] = 0x00 | (TX_RATE_14443A << 6) | (RX_RATE_14443A << 4);
	
	txbuf[3] = 0x51;
	length = 4;
	
	txbuf[4] = 0x00;	// PP (Optioanal) 															// 00
	txbuf[5] = 0x00;	// MM (Optioanal)															// 01
	txbuf[6] = 0x00;	// DD (Optioanal)															// 80
	txbuf[7] = 0x00;	// ST Reserved (Optioanal)
	txbuf[8] = 0x00;	// ST Reserved (Optioanal)

	send_pack(length);
	
	return 4;
	
	return 0;
}

static uint8_t _select_iso15693(void)
{
	txbuf[0] = 0x00;
	
	txbuf[1] = CR95_CMD_PROTOCOL;
	txbuf[2] = 2;// Length
	
	txbuf[3] = ISO_15693;
	txbuf[4] = 0x05;
	
	return 5;
}

static uint8_t _select_iso14443a(void)
{
	uint8_t length  = 0;
	
	txbuf[0] = CR95_CMD_PROTOCOL;
	txbuf[1] = 2;	// Data Length
	txbuf[2] = ISO_14443A;
	txbuf[3] = 0x00 | (TX_RATE_14443A << 6) | (RX_RATE_14443A << 4);

	length = 4;
	
	txbuf[4] = 0x00;	// PP (Optioanal) 															// 00
	txbuf[5] = 0x00;	// MM (Optioanal)															// 01
	txbuf[6] = 0x00;	// DD (Optioanal)															// 80
	txbuf[7] = 0x00;	// ST Reserved (Optioanal)
	txbuf[8] = 0x00;	// ST Reserved (Optioanal)

	send_pack(length);
	
	return 4;
}

static uint8_t _select_iso14443b(void)
{
	txbuf[0] = 0x00;
	
	txbuf[1] = CR95_CMD_PROTOCOL;
	txbuf[2] = 2;// Length
	
	txbuf[3] = ISO_14443B;
	// txbuf[4] = 0x00 | (TX_RATE_106 << 6) | (RX_RATE_106 << 4);	// (TX_RATE << 6) | (RX_RATE << 4) // 02
txbuf[4] = 0x01;


	txbuf[5] = 0x00;	// PP (Optioanal) 															// 00
	txbuf[6] = 0x00;	// MM (Optioanal)															// 01
	txbuf[7] = 0x00;	// DD (Optioanal)															// 80
	txbuf[8] = 0x00;	// ST Reserved (Optioanal)
	txbuf[9] = 0x00;	// ST Reserved (Optioanal)

	return 5;
}

static uint8_t send_pack(uint8_t len)
{	


	printf("SEND[%d] -> ", len);
	for(uint8_t i = 0; i < len; i++) {
		if(i == 1) printf("  [ ");
		printf(" %02X", txbuf[i]);
		if(i == 1) printf(" ]   ");
	}
	printf("\n");

	current_state = UMDK_CR95_PACK_ERROR;
	flag_rx = UMDK_CR95_NOT_RECIEVED;
	num_bytes_rx = 0;
	
	return ((*cr95_iface)(len));
}


static uint8_t _cmd_echo(void)
{
	current_cmd = CR95_CMD_ECHO;
	flag_rx = UMDK_CR95_NOT_RECIEVED;
	current_state = UMDK_CR95_PACK_ERROR;
	
	uint32_t time_begin = rtctimers_millis_now();
	uint32_t time_end = 0;
	uint32_t time_delta = 0;
	
	txbuf[0] = CR95_CMD_ECHO;
	
	msg_rx.type = UMDK_CR95_MSG_ECHO;
	send_pack(1);
	
	rtctimers_millis_sleep(CR95_ECHO_WAIT_TIME_MS);
	
	while(flag_rx != UMDK_CR95_RECIEVED) {
		time_end = rtctimers_millis_now();
		time_delta = time_end - time_begin;
		if(time_delta > UMDK_CR95_NO_RESPONSE_TIME_MS) {
			current_state = UMDK_CR95_PACK_ERROR;
			msg_send(&msg_rx, radio_pid);
			break;
		}
	}

	return (uint8_t)current_state;
}

static void *radio_send(void *arg)
{
    (void) arg;
    msg_t msg;
    msg_t msg_queue[16];
    msg_init_queue(msg_queue, 16);

	while (1) {
        msg_receive(&msg);

		cr95_msg_t  msg_type = (cr95_msg_t)msg.type;
		
#if ENABLE_DEBUG
		DEBUG("	%d:RX data[%d]: ", (uint8_t)msg_type, num_bytes_rx);
		for(uint32_t i = 0; i < num_bytes_rx; i++) {
				DEBUG(" %02X", rxbuf[i]);
			}	
		DEBUG("\n");
#endif
		
		switch(msg_type) {
			case UMDK_CR95_MSG_RADIO: {
				
				break;
			}
			
			case UMDK_CR95_MSG_ECHO: {
				current_cmd = 0;
				if(rxbuf[0 + offset] == CR95_CMD_ECHO) {
					current_state = UMDK_CR95_PACK_OK;
					flag_rx = UMDK_CR95_RECIEVED;
					_cmd_idn();
				}
				else {
					current_state = UMDK_CR95_PACK_ERROR;
					puts("[umdk-" _UMDK_NAME_ "] Device: not found");
				}
				
				flag_rx = UMDK_CR95_RECIEVED;
				rxbuf[0] = 0x00;
				rxbuf[1] = 0x00;
				num_bytes_rx = 0;
				break;
			}
			
			case UMDK_CR95_MSG_IDLE: {	
				// puts("		MSG IDLE");
				
				if(_check_pack(num_bytes_rx)) {			
					if(rxbuf[2 + offset] == 0x02) {
						// puts(" -> [DETECT]");
						current_state = UMDK_CR95_PACK_OK;
						flag_rx = UMDK_CR95_RECIEVED;
						
						_cmd_select_protocol();

					}
					else {
						current_state = UMDK_CR95_PACK_ERROR;
					}
				}
				else {
					current_state = UMDK_CR95_PACK_ERROR;
				}
				
				num_bytes_rx = 0;
				flag_rx = UMDK_CR95_RECIEVED;
				rtctimers_millis_set(&detect_timer, UMDK_CR95_DETECT_MS);
				// t2 = xtimer_now_usec();
				// printf("TIME: %ld\n", t2-t1);
				break;
			}
			
			case UMDK_CR95_MSG_PROTOCOL: {
				printf("		MSG PROTOCOL\n");
				current_cmd = 0x0;
				if(_check_pack(num_bytes_rx)) {				
					if((rxbuf[0 + offset] == 0x00) && (rxbuf[1 + offset] == 0x00)) {
						current_state = UMDK_CR95_PACK_OK;
						// puts("	OK");
						if(umdk_cr95_config.mode == CR95_READER) {
							msg_rx.type = UMDK_CR95_MSG_UID;
							_cmd_send_receive(send_1a, 2);
						}
						else if(umdk_cr95_config.mode == CR95_WRITER) {
							_cmd_send_receive(send_data, 10);
						}
						
					}
					else {
						current_state = UMDK_CR95_PACK_ERROR;
						// puts("	ERROR");
					}
				}
				else {
					current_state = UMDK_CR95_PACK_ERROR;
				}
				num_bytes_rx = 0;
				flag_rx = UMDK_CR95_RECIEVED;
				
				break;
			}
			
			case UMDK_CR95_MSG_ANTICOL: {	
				// printf("		MSG ANTICOL\n");	

				
				if(rxbuf[0 + offset] == 0x80) {
					uint32_t uid =  (rxbuf[5 + offset] << 24) + (rxbuf[4 + offset] << 16) + (rxbuf[3 + offset] << 8) + rxbuf[2 + offset];
					printf("	-> UID: ");
						printf(" %02X %02X %02X %02X", rxbuf[2 + offset], rxbuf[3 + offset], rxbuf[4 + offset], rxbuf[5 + offset]);
					printf(" ->  %"PRIu32"\n", uid);
				}
				else {
					puts("[ NOT VALID ANTICOL DATA ]");
					current_state = UMDK_CR95_PACK_ERROR;
				}
				
				num_bytes_rx = 0;				
				flag_rx = UMDK_CR95_RECIEVED;
				break;
			}
			
			case UMDK_CR95_MSG_UID: {
				// printf("		MSG UID\n");
				num_bytes_rx = 0;
				if(rxbuf[0 + offset] == 0x80) {
					current_state = UMDK_CR95_PACK_OK;
					msg_rx.type = UMDK_CR95_MSG_ANTICOL;
					
					_cmd_send_receive(send_2a, 3);
				}
				else {
					puts("[ NOT VALID UID DATA ]");
					current_state = UMDK_CR95_PACK_ERROR;
				}
				flag_rx = UMDK_CR95_RECIEVED;
				
				break;
			}
			
			case UMDK_CR95_MSG_IDN: {
				printf("[umdk-" _UMDK_NAME_ "] Device: ");
				for(uint32_t i = 2; i < 14; i++ ) {
					printf("%c", rxbuf[i]);
				}
				printf("\n");
				
				_calibration();
	
				break;
			}
			
			case UMDK_CR95_MSG_CALIBR: {
					num_bytes_rx = 0;
					/* First launch */
				if(dac_data_h == 0x00) {
					if(rxbuf[2] == 0x02) {
						dac_data_h = 0xFC;
						puts("[First launch calibration]");
						_calibration();
					}
					else {
						puts("[umdk-" _UMDK_NAME_ "] Error calibration tag detection");
					}
				}
				else if(dac_data_h > 0x02) {	/* Calibration */
					if(rxbuf[2] == 0x02) {						
						dac_data_l = dac_data_h;
						dac_data_h = 0xFC;
						
						printf("\n			FINISH:  %02X  / %02X\n", dac_data_l, dac_data_h);
						
						if(umdk_cr95_config.mode == CR95_READER) {
							rtctimers_millis_set(&detect_timer, UMDK_CR95_DETECT_MS);
						}
						break;
					}
					else if(rxbuf[2] == 0x01) {
						dac_data_h -= 0x04;
						_calibration();
					}
					else {
						puts("[umdk-" _UMDK_NAME_ "] Error calibration tag detection");
					}
				}
				
				break;
			}
			
			default: 
				break;
		}
				
    }
    return NULL;
}

// static void reset_config(void) {
	// umdk_modbus_config.baudrate = UMDK_MODBUS_BAUDRATE_DEF;
    // umdk_modbus_config.databits = UART_DATABITS_8;
    // umdk_modbus_config.parity = UART_PARITY_NOPARITY;
    // umdk_modbus_config.stopbits = UART_STOPBITS_20;
	// umdk_modbus_config.uart_dev = UMDK_UART_DEV;
// }

void cr95_uart_rx(void *arg, uint8_t data)
{
	(void) arg;
	
	if(num_bytes_rx >= 30) {
		puts("OVERFLOW");
		return;
	}
	
	if(uart_rx == 0) {
		puts("RX UART NOT ALLOW");
		return;
	}
		
	rxbuf[num_bytes_rx] = data;
	num_bytes_rx++;
	
	xtimer_set_msg(&rx_timer, UMDK_CR95_UART_TIME_RX_USEC, &msg_rx, radio_pid);
	
	return;
}

static bool _check_pack(uint8_t length) 
{
	if((length - 2) != rxbuf[1]) {
		puts("Wrong pack length");
		return false;
	}
	
	return true;
}

static uint8_t _send_uart(uint8_t length)
{	
	num_bytes_rx = 0;
    uart_write(UART_DEV(cr95_params.uart), txbuf, length);
	
	return 1;
}

static void cr95_spi_rx(void* arg)
{
	(void) arg;

	gpio_irq_disable(UMDK_CR95_IRQ_OUT);
	
	uint8_t tx_rx = 0x02;
	
	spi_transfer_bytes(SPI_DEV(cr95_params.spi), cr95_params.cs_spi, true, &tx_rx, NULL, 1);
	spi_transfer_bytes(SPI_DEV(cr95_params.spi), cr95_params.cs_spi, false, NULL, rxbuf, sizeof(rxbuf));
		
	spi_release(SPI_DEV(cr95_params.spi));
	
	if(current_cmd == CR95_CMD_ECHO) {
		num_bytes_rx = 1;
	}
	else {
		num_bytes_rx = rxbuf[1] + 2;
	}
	
	msg_send(&msg_rx, radio_pid);
	
	return;
}	

static uint8_t _send_spi(uint8_t length) 
{
	num_bytes_rx = 0;
	uint8_t tx_spi = 0x00;

	spi_acquire(SPI_DEV(cr95_params.spi), cr95_params.cs_spi, SPI_MODE_0, UMDK_CR95_SPI_CLK);
	
	/*Send command*/
	spi_transfer_bytes(SPI_DEV(cr95_params.spi), cr95_params.cs_spi, true, &tx_spi, NULL, 1);
	spi_transfer_bytes(SPI_DEV(cr95_params.spi), cr95_params.cs_spi, false, txbuf, NULL, length);
	
	gpio_irq_enable(UMDK_CR95_IRQ_OUT);
	
	// xtimer_usleep(15);
	
	return 1;
}


static uint8_t cr95_select_iface(uint8_t iface)
{		
	gpio_init(UMDK_CR95_SSI_0, GPIO_OUT);
	// gpio_init(cr95_params.ssi_0, GPIO_OUT);
	gpio_init(UMDK_CR95_IRQ_IN, GPIO_OUT);
	
	// TODO: Set "power on" CR95HF

	if(iface == CR95_IFACE_UART) {	
			/* Initialize the UART params*/
		uart_params_t params;
		params.baudrate = UMDK_CR95_UART_BAUD_DEF;
		params.databits = UART_DATABITS_8;
		params.parity = UART_PARITY_NOPARITY;
		params.stopbits = UART_STOPBITS_10;
	
				/* Select UART iface */
		gpio_clear(UMDK_CR95_SSI_0);	
			/* Set low level IRQ_IN/RX */
		gpio_set(UMDK_CR95_IRQ_IN);
		rtctimers_millis_sleep(CR95_RAMP_UP_TIME_MS);
		gpio_clear(UMDK_CR95_IRQ_IN);
		rtctimers_millis_sleep(CR95_RAMP_UP_TIME_MS);
		
		/* Initialize UART */
		gpio_init_af(UMDK_CR95_IRQ_IN, GPIO_AF7);
		if (uart_init_ext(UART_DEV(cr95_params.uart), &params, cr95_uart_rx, NULL)) {
			printf("[umdk-" _UMDK_NAME_ "] Error init UART interface: %02d \n", cr95_params.uart);
			return 0;
		}
		else {
			printf("[umdk-" _UMDK_NAME_ "] Init UART interface: %02d \n", cr95_params.uart);
		}
	
		gpio_clear(UMDK_CR95_SSI_0);
		cr95_iface = &_send_uart;
	
		uart_rx = 1;
		offset = 0;
	}
	else if(iface == CR95_IFACE_SPI) {	
		/* Select SPI iface */
		gpio_set(UMDK_CR95_SSI_0);
			/* Set low level IRQ_IN/RX */
		gpio_set(UMDK_CR95_IRQ_IN);
		rtctimers_millis_sleep(CR95_RAMP_UP_TIME_MS);
		gpio_clear(UMDK_CR95_IRQ_IN);
		rtctimers_millis_sleep(CR95_RAMP_UP_TIME_MS);
		
			 /* Initialize SPI */
		spi_init(SPI_DEV(cr95_params.spi));
		 /* Initialize CS SPI */
		if(spi_init_cs(SPI_DEV(cr95_params.spi), cr95_params.cs_spi) == SPI_OK) {
			printf("[umdk-" _UMDK_NAME_ "] Init SPI interface: %02d\n", cr95_params.spi);
		}
		else {
			printf("[umdk-" _UMDK_NAME_ "] Error init SPI interface: %02d\n", cr95_params.spi);
			return 0;
		}
		
		gpio_init_int(UMDK_CR95_IRQ_OUT, GPIO_IN_PU, GPIO_FALLING, cr95_spi_rx, NULL);
		gpio_irq_enable(UMDK_CR95_IRQ_OUT);
		gpio_irq_disable(UMDK_CR95_IRQ_OUT);
	
		gpio_set(UMDK_CR95_SSI_0);
		cr95_iface = &_send_spi;

		uart_rx = 0;
		offset = 0;
	}
	else {
		puts("[umdk-" _UMDK_NAME_ "] Error selecting interface");
		return 0;
	}
	
	rtctimers_millis_sleep(CR95_HFO_SETUP_TIME_MS);

	return 1;
}

static uint8_t _calibration(void)
{
	
	// printf("\nDacData:  %02X  / %02X\n", dac_data_l, dac_data_h);
	msg_rx.type = UMDK_CR95_MSG_CALIBR;
	
	current_cmd = 0x66;
	// txbuf[0] = CR95_CMD_IDLE;
	// txbuf[1] = 14;				// Data Length 
	
	// txbuf[2] = 0x03;	
	
	// txbuf[3] = 0x21;
	// txbuf[4] = 0x00;
	// txbuf[5] = 0x79;
	// txbuf[6] = 0x01;
	// txbuf[7] = 0x18;
	// txbuf[8] = 0x00;
	
	// txbuf[9] = 0x02;
	
	// txbuf[10] = 0x60;
	// txbuf[11] = 0x60;
	
	// txbuf[12] = 0x00;
	// txbuf[13] = 0x00;
	
	// txbuf[14] = 0x3F;
	// txbuf[15] = 0x01;
	
	// uint8_t CAL[] =   {0x07, 0x0E, 0x03, 0xA1, 0x00, 0xF8, 0x01, 0x18, 0x00, 0x01, 0x60, 0x60, 0x00, 0xFE, 0x3F, 0x01};
	
	// uint8_t cal[16] = {0x07, 0x0E, 0x03, 0x21, 0x00,  0x79, 0x01, 0x18, 0x00, 0x02, 0x60, 0x60, 0x00, 0x00, 0x3F, 0x01};
	
	txbuf[0] = CR95_CMD_IDLE;	// Command
	txbuf[1] = 14;				// Data Length 
	/* Idle params */
		/* Wake Up Source */
	txbuf[2] = 0x03;			// Tag Detection + Time out
		/* Enter Control (the resources when entering WFE mode)*/
	txbuf[3] = 0xA1;			// Tag Detector Calibration
	txbuf[4] = 0x00;			// 
		/* Wake Up Control (the wake-up resources) */
	txbuf[5] = 0xF8;			// Tag Detector Calibration
	txbuf[6] = 0x01;			//
		/* Leave Control (the resources when returning to Ready state)*/
	txbuf[7] = 0x18;			// Tag Detection
	txbuf[8] = 0x00;	
		/* Wake Up Period (the time allowed between two tag detections) */
	txbuf[9] = 0x02;			// 
		/* Osc Start (the delay for HFO stabilization) */
	txbuf[10] = 0x60;			// Recommendeded value 0x60
		/* DAC Start (the delay for DAC stabilization) */
	txbuf[11] = 0x60;			// Recommendeded value 0x60
	
	
		/* DAC Data */
	txbuf[12] = dac_data_l;			// DacDataL
	txbuf[13] = dac_data_h;			// DacDataH
	
	
		/* Swing Count */
	txbuf[14] = 0x3F;			// Recommendeded value 0x3F
		/* Max Sleep */
	txbuf[15] = 0x01;			// This value must be set to 0x01 during tag detection calibration
	
	
	send_pack(16);
	
	return  1;
}

static void reset_config(void) {
	umdk_cr95_config.iface = CR95_IFACE_UART;
	umdk_cr95_config.mode = CR95_READER;
	umdk_cr95_config.protocol = ISO14443A_SELECT;
}

static inline void save_config(void) {
	unwds_write_nvram_config(_UMDK_MID_, (uint8_t *) &umdk_cr95_config, sizeof(umdk_cr95_config));
}

static void init_config(void) {
	reset_config();
	
	if (!unwds_read_nvram_config(_UMDK_MID_, (uint8_t *) &umdk_cr95_config, sizeof(umdk_cr95_config))) {
		reset_config();
        return;
    }
	
    if (umdk_cr95_config.iface > CR95_IFACE_SPI) {
		reset_config();
		return;
    }
	
	if (umdk_cr95_config.mode > CR95_READER) {
		reset_config();
		return;
    }
	
	if (umdk_cr95_config.protocol > SELECT_ALL_PROTOCOL) {
		reset_config();
		return;
    }
}

void umdk_cr95_init(uint32_t *non_gpio_pin_map, uwnds_cb_t *event_callback)
{
	(void)non_gpio_pin_map;
	
	(void)event_callback;
	// callback = event_callback;

	// save_config();
	init_config();	
	
	if(umdk_cr95_config.mode == CR95_WRITER) {
			puts("WRITER mode");
		}
		else if(umdk_cr95_config.mode == CR95_READER) {
			puts("READER mode");
		}
	
	
	if(!cr95_select_iface(umdk_cr95_config.iface)) {
		return;
	}
	
	 /* Create handler thread */
    char *stack = (char *) allocate_stack(UMDK_CR95_STACK_SIZE);
    if (!stack) {
        puts("[umdk-" _UMDK_NAME_ "] unable to allocate memory. Is too many modules enabled?");
        return;
    }
	
	radio_pid = thread_create(stack, UMDK_CR95_STACK_SIZE, THREAD_PRIORITY_MAIN - 1, THREAD_CREATE_STACKTEST, radio_send, NULL, "cr95 thread");
	
	memset(txbuf, 0x00, 30);
	memset(rxbuf, 0x00, 30);

			rtctimers_millis_sleep(950);
	
	_cmd_echo();
	
	
	// protocol = ISO14443A_SELECT;
	protocol = umdk_cr95_config.protocol;
	
	

		
	// puts("		--->	START CR95 DETECTing	<---");
	 /* Configure periodic wakeup */
    detect_timer.callback = &detect_handler;
    // rtctimers_millis_set(&detect_timer, UMDK_CR95_DETECT_MS);

}


// static inline void reply_code(module_data_t *reply, cr95_reply_t code) 
// {
	// reply->as_ack = true;
	// reply->length = 2;
	// reply->data[0] = _UMDK_MID_;
	// reply->data[1] = code;
// }


bool umdk_cr95_cmd(module_data_t *cmd, module_data_t *reply)
{	
	memset(txbuf, 0x00, 30);
	memset(rxbuf, 0x00, 30);

	printf("Data: ");
	for(uint32_t i = 0; i < cmd->length; i++) {
		printf(" %02X", cmd->data[i]);
	}
	printf("\n");
	if(cmd->data[0] == 0x00) {	// Send data
	
		_cmd_select_protocol();
		// memcpy(txbuf, cmd->data + 1, cmd->length);
		
	
	}
	else if(cmd->data[0] == 0x01) {	// IFACE
		if(cmd->data[1] == CR95_IFACE_UART) {
			umdk_cr95_config.iface = CR95_IFACE_UART;
			puts("UART iface");
		}
		else if(cmd->data[1] == CR95_IFACE_SPI) {
			umdk_cr95_config.iface = CR95_IFACE_SPI;
			puts("SPI iface");
		}
		save_config();
	}
	else if(cmd->data[0] == 0x02) {	// MODE
		if(cmd->data[1] == CR95_WRITER) {
			umdk_cr95_config.mode = CR95_WRITER;
			puts("WRITER mode");
		}
		else if(cmd->data[1] == CR95_READER) {
			umdk_cr95_config.iface = CR95_READER;
			puts("READER mode");
		}
				save_config();
	}
	else if(cmd->data[0] == 0x03) {	// PROTOCOL
			
	}	
	
	return false;
	
	
_cmd_idn();
_select_field_off();

_select_iso14443a();
_select_iso14443b();
_select_iso15693();
    rtctimers_millis_set(&detect_timer, UMDK_CR95_DETECT_MS);
	
	
	
	reply->as_ack = true;	
	reply->length = 1;
	reply->data[0] = _UMDK_MID_;
	
	return true; /* Allow reply */
}


#ifdef __cplusplus
}
#endif
