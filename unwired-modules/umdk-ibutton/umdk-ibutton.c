/*
 * Copyright (C) 2017 Unwired Devices [info@unwds.com]
 *
 * This file is subject to the terms and conditions of the GNU Lesser
 * General Public License v2.1. See the file LICENSE in the top level
 * directory for more details.
 */

/**
 * @defgroup
 * @ingroup
 * @brief
 * @{
 * @file        umdk-ibutton.c
 * @brief       umdk-ibutton module implementation
 * @author      Mikhail Perkov
 */

#ifdef __cplusplus
extern "C" {
#endif

/* define is autogenerated, do not change */
#undef _UMDK_MID_
#define _UMDK_MID_ UNWDS_IBUTTON_MODULE_ID

/* define is autogenerated, do not change */
#undef _UMDK_NAME_
#define _UMDK_NAME_ "ibutton"

#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <limits.h>

#include "periph/gpio.h"

#include "unwds-common.h"

#include "board.h"
#include "onewire.h"
#include "umdk-ibutton.h"

#include "lpm.h"
#include "thread.h"
#include "rtctimers.h"
#include "periph/rtc.h"

#define ENABLE_DEBUG 0
#include "debug.h"

static const uint8_t Crc8Table[256] =  {
            0, 94, 188, 226, 97, 63, 221, 131, 194, 156, 126, 32, 163, 253, 31, 65,
            157, 195, 33, 127, 252, 162, 64, 30, 95, 1, 227, 189, 62, 96, 130, 220,
            35, 125, 159, 193, 66, 28, 254, 160, 225, 191, 93, 3, 128, 222, 60, 98,
            190, 224, 2, 92, 223, 129, 99, 61, 124, 34, 192, 158, 29, 67, 161, 255,
            70, 24, 250, 164, 39, 121, 155, 197, 132, 218, 56, 102, 229, 187, 89, 7,
            219, 133, 103, 57, 186, 228, 6, 88, 25, 71, 165, 251, 120, 38, 196, 154,
            101, 59, 217, 135, 4, 90, 184, 230, 167, 249, 27, 69, 198, 152, 122, 36,
            248, 166, 68, 26, 153, 199, 37, 123, 58, 100, 134, 216, 91, 5, 231, 185,
            140, 210, 48, 110, 237, 179, 81, 15, 78, 16, 242, 172, 47, 113, 147,205,
            17, 79, 173, 243, 112, 46, 204, 146, 211, 141, 111, 49, 178, 236, 14, 80,
            175, 241, 19, 77, 206, 144, 114, 44, 109, 51, 209, 143, 12, 82, 176, 238,
            50, 108, 142, 208, 83, 13, 239, 177, 240, 174, 76, 18, 145, 207, 45, 115,
            202, 148, 118, 40, 171, 245, 23, 73, 8, 86, 180, 234, 105, 55, 213, 139,
            87, 9, 235, 181, 54, 104, 138, 212, 149, 203, 41, 119, 244, 170, 72, 22,
            233, 183, 85, 11, 136, 214, 52, 106, 43, 117, 151, 201, 74, 20, 246, 168,
            116, 42, 200, 150, 21, 75, 169, 247, 182, 232, 10, 84, 215, 137, 107, 53};


static uwnds_cb_t *callback;
static kernel_pid_t ibutton_pid;

static msg_t detect_msg = {.type = MSG_DETECT,     .content.value = 0, };


static uint8_t id_detected[UMDK_IBUTTON_SIZE_ID] = { 0 };

static int led_gpio_enabled = 0;

static uint8_t crc8(uint8_t *ptrBlock, uint8_t length)
{
    uint8_t crc = 0x00;

    while (length--) {
        crc = Crc8Table[crc ^ *ptrBlock++];
    }
    
    return crc;
}

static uint8_t check_crc(void)
{
    uint8_t crc_rx = id_detected[UMDK_IBUTTON_SIZE_ID - 1];
    uint8_t crc = crc8(id_detected, UMDK_IBUTTON_SIZE_ID - 1);
    
    if(crc_rx != crc) {
        puts("[umdk-" _UMDK_NAME_ "] Error -> Wrong CRC");
        return CRC_WRONG;
    }
    
    return CRC_RIGHT;
}

static int detect_device(void)
{ 
    /* Look for iButton device */    
    onewire_sendbyte(UMDK_IBUTTON_READ_ROM); 
    
    /* Read 64-bit device ID */
    for (int i = 0; i < UMDK_IBUTTON_SIZE_ID; i++) {
        id_detected[i] = onewire_readbyte();    
    }
    
    /* Incorrect ID family */    
    if (id_detected[0] == 0)
        return DEVICE_ERROR;
        
    /* Check CRC */
    if (check_crc() == CRC_RIGHT) {
        return DEVICE_OK;    
    }

    return DEVICE_ERROR;
}

static void *radio_send(void *arg)
{
    msg_t msg;
    msg_t msg_queue[4];
    msg_init_queue(msg_queue, 4);

    while (1) {
        msg_receive(&msg);
        module_data_t data;

        data.data[0] = _UMDK_MID_;
        data.length = 1;
                                  
        memcpy(&data.data[1], id_detected,  UMDK_IBUTTON_SIZE_ID);
        data.length += UMDK_IBUTTON_SIZE_ID;
        
        gpio_set(UMDK_IBUTTON_LED_GPIO);
        led_gpio_enabled = (1000*UMDK_IBUTTON_GRANTED_PERIOD_SEC)/UMDK_IBUTTON_POLLING_PERIOD_MS;
        
        printf("[" _UMDK_NAME_ "] i-Button detected, ID ");
        for(int i = data.length - 1; i > 0; i--) {
            printf("%02X ", data.data[i]);
        }
        printf("\n");

        data.as_ack = false;
        callback(&data);
    }
    
    return NULL;
} 

static void detect_handler(void *arg) 
{
    (void) arg;
    if (led_gpio_enabled) {
        if (--led_gpio_enabled == 0) {
            gpio_clear(UMDK_IBUTTON_LED_GPIO);
        }
    }
    else {
        if (onewire_detect()) {
            if (detect_device() == DEVICE_OK) {
                msg_try_send(&detect_msg, ibutton_pid);
            }
        }
    }
}

void umdk_ibutton_init(uint32_t *non_gpio_pin_map, uwnds_cb_t *event_callback)
{
    (void) non_gpio_pin_map;
    lpm_prevent_switch = 1;

    callback = event_callback;
    
    /* Initialize 1-Wire bus driver */
    onewire_init(UMDK_IBUTTON_DEV);
    
    gpio_init(UMDK_IBUTTON_LED_GPIO, GPIO_OUT);
    gpio_clear(UMDK_IBUTTON_LED_GPIO);
    lpm_arch_add_gpio_exclusion(UMDK_IBUTTON_LED_GPIO);
    
    /* Create handler thread */
    char *stack = (char *) allocate_stack();
    if (!stack) {
        puts("umdk-ibutton: unable to allocate memory. Is too many modules enabled?");
        return;
    }
    ibutton_pid = thread_create(stack, UNWDS_STACK_SIZE_BYTES, THREAD_PRIORITY_MAIN - 1, THREAD_CREATE_STACKTEST,
                                radio_send, NULL, "ibutton thread");
    
    /* Configure periodic wakeup */
    rtc_set_wakeup(UMDK_IBUTTON_POLLING_PERIOD_MS*1e3, &detect_handler, NULL);
    rtc_enable_wakeup();
}

static inline void reply_error(module_data_t *reply) 
{
    reply->as_ack = true;
    reply->length = 2;
    reply->data[0] = _UMDK_MID_;
    reply->data[1] = 0;
}

static inline void reply_ok(module_data_t *reply) 
{
    reply->as_ack = true;
    reply->length = 2;
    reply->data[0] = _UMDK_MID_;
    reply->data[1] = 1;;
}

bool umdk_ibutton_cmd(module_data_t *cmd, module_data_t *reply)
{
    if (cmd->length < 1) {
        return false;
    }

    umdk_ibutton_cmd_t c = cmd->data[0];
    
    switch (c) {
        default: {
            reply_error(reply);
            return true;
            break;
        }
    }
    /* Don't reply by default */
    return false;
}

#ifdef __cplusplus
}
#endif
